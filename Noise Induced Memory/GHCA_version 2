import matplotlib.pyplot as plt
import numpy as np
import random
import copy
import line_profiler 
import atexit

profile = line_profiler.LineProfiler()
atexit.register(profile.print_stats) #call print_stats at the end of script

L = 2000 #System size
p = 0.00002 #Probability of spontaneous excitation/node activation prob
R = 100 #Refractory period/time step delay from R to Q
T = 2000 #Number of time steps to run for

class GHCA:
    def __init__(self,size=L, prob=p, refac=R, time=T):
        self.size=size 
        self.r=refac 
        self.p=prob 
        self.time=time
        self.lattice_before= np.zeros(self.size,dtype=int)
        self.lattice_after= np.zeros(self.size,dtype=int)
        self.count=0
        self.x=[]
        self.y=[]
        self.skip=0
        #self.time_array=list(range(0, self.time))
        #self.matrix=[[0 for i in range(self.time)] for j in range(self.size)]
        #self.matrix=np.array(x[:] for x in [[0] * self.time] * self.size)
        self.matrix=np.zeros((self.size,self.time), dtype=int)
        
    def poisson_fire(self, excitation_p=1, number=10 ):
        
        # Request random integers between 0 and 3 (exclusive)
        indices_i = np.random.randint(0, high=self.time-1, size=number)
        indices_j = np.random.randint(0, high=self.size-1, size=number)
       
        # Extract the row and column indices
        for i,j in zip(indices_i, indices_j):
            q = random.uniform(0,1)
            if q<=excitation_p:
                self.matrix[0][i][j]=1
        

    def initial_fire(self):
        #the initial state of the system stored in adjacency list 
        rand_fire=np.random.randint(0,self.size-1)
        self.lattice_before[rand_fire]=1
        #self.lattice_after=self.lattice_before <-this is why it was propagating one side!
        #python is taking the two list as the SAME object at this point
        
        return rand_fire
                     
    #check if neighbour is in rest state
    def check_neighbours(self, index):
        
        edge=self.size-1
        
        if index==0:
            if self.lattice_before[1]==0:
                self.lattice_after[1]=1
                self.y.append(1)
                self.x.append(self.count+1)
                self.skip=1
        elif index==edge:
            if self.lattice_before[edge-1]==0:
                self.lattice_after[edge-1]=1
                self.y.append(edge-1)
                self.x.append(self.count+1)

        else:
            #print(self.lattice_before,index)
            if self.lattice_before[index-1]==0:
                self.lattice_after[index-1]=1
                self.y.append(index-1)
                self.x.append(self.count+1)
            if self.lattice_before[index+1]==0:
                self.lattice_after[index+1]=1
                skip_right=1
                self.y.append(index+1)
                self.x.append(self.count+1)
                self.skip=1
            


    
    @profile
    def run(self):
        initial=self.initial_fire()

        self.x=[]  
        self.y=[] 
        
        #consecutive positions of leaders
        cp_x=[]
        cp_y= []
        cp_x.append(0)
        cp_y.append(initial)
        
        #leader position drift as a function of time lag
        diff_x = []
        diff_y = []
        
        #plt.ion()

        #fig = plt.figure()
        #ax = fig.add_subplot(111)
        #line1, = ax.plot(x, y, 'r-') 
        
        while self.count<=self.time:
           
            for i, state in enumerate(self.lattice_before):
  
                if self.skip==1:
                    self.skip=0
                    continue
                
            
                elif state == 0:
                    q=random.uniform(0,1)
                    if q<=self.p:
                        new_state = 1
                        self.lattice_after[i]=new_state
                    else:
                        self.lattice_after[i]=state
                    
 
                elif state==2:
                    new_state=state+self.r-1
                    self.lattice_after[i]=new_state
                elif state>3:
                    new_state=state-1
                    self.lattice_after[i]=new_state
                elif state==3:
                    new_state=0
                    self.lattice_after[i]=new_state
                elif state==1:
                    
                    self.y.append(i)
                    self.x.append(self.count)
                    new_state=2
                    self.lattice_after[i]=new_state
                    
                    self.check_neighbours(i)
         
                        
                  
                    
                    #line1.set_ydata(i)
                    #line1.set_xdata(self.count)
                    #fig.canvas.draw()
                    #fig.canvas.flush_events()
                    
                else:
                    new_state=0


            if 1 not in self.lattice_before and 1 in self.lattice_after:
                
                #leader_index=np.where(self.lattice_after==1)[0][0]
               # indices=[i for i,d in enumerate(self.lattice_after) if d==1]
                #next_time=self.count+1
                #cp_y.append(sum(indices,[]))
                #cp_x.append(next_time*len(indices))
                
                for i,d in enumerate(self.lattice_after):
                    if d==1:
                        cp_x.append(self.count+1)
                        cp_y.append(i)
                

                #cp_y.append(sum(indices,[]))
                #cp_x.append(next_time*len(indices))
                
            self.lattice_before=copy.deepcopy(self.lattice_after)
            self.count+=1
        
      
        for i in range(1,len(cp_x)):
            time_lag = cp_x[i] - cp_x[i-1]
            drift = cp_y[i] - cp_y[i-1]
            diff_x.append(time_lag)
            diff_y.append(drift)

        fig0 = plt.figure(0)
        ax1 = fig0.add_subplot(211)
        ax1.plot(self.x,self.y, '.')
        ax1.set_xlabel('Time (s)')
        ax1.set_ylabel('Positoin Index')
        
        
        ax2 = fig0.add_subplot(212)
        ax2.plot(cp_x,cp_y,'.')
        ax2.set_xlabel('Time(s)')
        ax2.set_ylabel('Leader Position')

        fig1 = plt.figure(1)
        ax3 = fig1.add_subplot(211)
        ax3.plot(diff_x, diff_y,'.')
        ax3.set_xlabel('Time lag')
        ax3.set_ylabel('Leader Drift in Position')
        ax4 = fig1.add_subplot(212)
        ax4.plot(np.log10(diff_x), np.log10(diff_y), '.')
 
    def Left_index(self,points): 
      #Finding the left most point 
    
        minn = 0
        for i in range(1,len(points)): 
            if points[i].x < points[minn].x: 
                minn = i 
            elif points[i].x == points[minn].x: 
                if points[i].y > points[minn].y: 
                    minn = i 
        return minn 

    
    
    def kinetic(self):
        rand_time, rand_pos = self.poisson_fire()
        for i in self.time_array:
            if i in rand_time:
                fire=rand_pos[i]
                self.lattice_before[fire]=1
        

                #open boundary condition

lattice = GHCA()
lattice.run()

        
        
