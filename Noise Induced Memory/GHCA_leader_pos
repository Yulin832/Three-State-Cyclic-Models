import matplotlib.pyplot as plt
import numpy as np
import random
from scipy.stats import binned_statistic
from collections import defaultdict
import line_profiler 
import atexit

profile = line_profiler.LineProfiler()
atexit.register(profile.print_stats) #call print_stats at the end of script

L = 128 #System size
p = 0.01 #Probability of spontaneous excitation/node activation prob
R = 128 #Refractory period/time step delay from R to Q
T = 2000000 #Number of time steps to run for

class GHCA:
    def __init__(self,size=L, prob=p, refrac=R, tot_t=T):
        self.L=size
        self.R=refrac 
        self.p=prob 
        self.T=tot_t
        #self.initial_site = np.random.randint(L)
        self.initial_site = self.L//2

    def initial_fire(self):
        
        self.exc_array = np.zeros(self.L,dtype=np.bool)
        self.ref_array = np.ones(self.L,dtype=np.bool)
        self.exc_index = [np.array([-1])] * self.R #List of arrays where each list contains cells excited at t%R
        
        self.exc_array[self.initial_site] = True
        self.ref_array[self.initial_site] = False
        self.exc_index[0] = np.array([self.initial_site]) #Fill excited index
        
        self.exc_dump = [self.initial_site] #Store sites excited at each timestep
        self.times = [0] #Store time site was excited
        
    @profile
    def run(self):
        initial=self.initial_fire()
        indices = np.arange(self.L)
        
        
        t=0 #initial time
        for i in range(self.T):
              
             prob_array = np.random.rand(self.L)<self.p #gives a boolean array
             exc_right = (self.exc_index[t%self.R]+1)%self.L #Sites to the right of previously excited
             exc_left = (self.exc_index[t%self.R]-1)%self.L #Sites to the right of previously
             
             self.exc_array *= False
             self.exc_array[exc_right] = True
             self.exc_array[exc_left] = True
             self.exc_array += prob_array #Add spontaneous excitations
             self.exc_array *= self.ref_array #Remove refractory cells
             exc_ind = indices[self.exc_array] #indices of the excited state
             
             self.ref_array[exc_ind] = 0 
             t += 1

             if t >= self.R:
                 self.ref_array[self.exc_index[t % self.R]] = 1 #Cells which excited R steps ago enter resting state
             self.exc_index[t % self.R] = exc_ind #Replace excited cell index
             
             self.exc_dump += exc_ind.tolist() #Store excited cells for plotting
             self.times += [t] * len(exc_ind) #Store time cell was activated at
            
                
             #leader position trial
            # if len(self.exc_index[(t-1)%R])==0 and len(exc_ind)>=1:
             #    self.leader_time += [t] * len(exc_ind)
              #   self.leader_pos += exc_ind.tolist()
                 #but if waves overlap the leaders are not recorded
      
        '''
        ave_pos=[]
        ave_time=[]             
        for i, item_i in enumerate(self.leader_pos):
            for j, item_j in enumerate(self.leader_pos):
                if i!= j:
                    average_pos = [abs((item_i-item_j)/(i-j))]
                    average_time = [(self.leader_time[i]-self.leader_time[j])/(i-j)]
                    
                    ave_pos += average_pos
                    ave_time += average_time
                    
       '''
 
             
     
        #plt.figure(0)
        #plt.scatter(self.times,self.exc_dump,s=0.5)
        
        #plt.xlabel('Time(s)')
        #plt.ylabel('Space(n)')
         
       # plt.subplot(2,1,2)
       # plt.scatter(self.leader_time, self.leader_pos)
       # plt.xlabel('Time(s)')
        #plt.ylabel('Leader position(n)')
        
        
        #plt.figure(1)
        #plt.subplot(2,1,1)
        #plt.scatter(ave_pos, ave_time)
    def plot_leader(self):
        #consecutive positions of leaders        
        self.leader_pos = [self.initial_site]
        self.leader_time = [0]
        #use a dictionary
        #my_dict = {i:self.exc_dump for i in self.times}
        #condense two lists into one
        my_dict = defaultdict(list)
        for a, b in zip(self.times, self.exc_dump):
            my_dict[a].append(b)
        
        time_list = list(my_dict.keys())
        #dict(my_dict))

        time_count = 0
        skip = self.R
    
        for i,v in enumerate(time_list):
            if i == 0:
                pass
            elif time_list[i] - time_list[i-1] > 1:
                self.leader_pos += my_dict[v]
                time_count += 1
                self.leader_time += [time_count]*len(my_dict[v])
     
        
        plt.figure(1)
        plt.scatter(self.leader_time, self.leader_pos, s=0.8)
        plt.xlabel('Time')
        plt.ylabel('Leader(t)')

    def plot_leaderDistribution(self):
        #distribution of leader drift in position in next wavefront
        diff_x = []

        for i, pos in enumerate(self.leader_pos[1:]):
            diff = abs(pos - self.leader_pos[i-1])
            max_diff = self.L/2
            if diff > max_diff:
                diff = self.L - diff
            diff_x.append(diff)
        my_dict = {i:diff_x.count(i) for i in diff_x}
   
        diff_y = list(my_dict.values())
        diff_x = list(my_dict.keys())

        plt.figure(2)
        ax = plt.gca()
        ax.plot(diff_x, diff_y,'.')
        ax.set_yscale('log')
        ax.set_xscale('log')
        ax.set_xlabel('Δn')
        ax.set_ylabel('P(Δn)')
        

    def plot_leaderDrift(self):
        #leader drift in position as a function of time
        diff_x = []
        diff_t = []

        for i, pos in enumerate(self.leader_pos[1:]):
            diff_xx = abs(pos - self.leader_pos[i-1])
            diff_tt = abs(self.times[i] - self.times[i-1])
            
            max_diff = self.L/2
            if diff_xx > max_diff:
                diff_xx = self.L - diff_xx
            diff_x.append(diff_xx)
            diff_t.append(diff_tt)

        
        # log-scaled bins: 0-1000 (excl.1000) and so on
        bins = np.logspace(0, 4, 10)
        #widths = (bins[1:] - bins[:-1])
        
        # Calculate histogram
        #counts, bin_edges = np.histogram(diff_t, bins=bins)
        
        # d is an index array holding the bin id for each point in diff_t
        #d = np.digitize(diff_t, bins)  
        
        stat, bin_edges, binnum = binned_statistic(diff_t, diff_t, statistic='max', bins=bins)
        
        x= []
        t= []
        for i in range(len(diff_t)):
            if diff_t[i] in stat:
                t.append(diff_t[i])
                x.append(diff_x[i])
                
            
        
        plt.figure(3)
        ax = plt.gca()
        ax.plot(t, x,'.')
        ax.set_yscale('log')
        ax.set_xscale('log')
        ax.set_xlabel('Δt')
        ax.set_ylabel('Δn')
    


lattice = GHCA()
lattice.run()
lattice.plot_leader()
#lattice.plot_leaderDistribution()
#lattice.plot_leaderDrift()
'''
i=0
while i<7:
    L=L*2
    R=R*2
    lattice = GHCA(size=L, refrac=R)
    lattice.run()
    lattice.plot_leader()
    lattice.plot_leaderDistribution()
    i+=1
'''      
        
