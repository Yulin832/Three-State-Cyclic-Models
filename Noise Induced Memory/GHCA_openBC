# -*- coding: utf-8 -*-
"""
Created on Sat Mar 20 12:46:40 2021

@author: elim2
"""

import numpy as np
import line_profiler 
import atexit


profile = line_profiler.LineProfiler()
atexit.register(profile.print_stats) #call print_stats at the end of script

L = 2048 #System size
p = 0.01 #Probability of spontaneous excitation/node activation prob
R = L #Refractory period/time step delay from R to Q
T = 10**5 #Number of wavefronts

class GHCA:
    def __init__(self,size=L, prob=p, refrac=R, waves=T):
        self.L=size
        self.R=refrac 
        self.p=prob 
        self.T=waves
        #self.initial_site = self.L//2
       
        
    def initial_fire(self):
        self.initial_site = np.random.randint(self.L)
        self.exc_array = np.zeros(self.L,dtype=np.bool)
        self.ref_array = np.ones(self.L,dtype=np.bool)
        self.exc_index = [np.array([-1])] * self.R #List of arrays where each list contains cells excited at t%R
        
        self.exc_array[self.initial_site] = True
        self.ref_array[self.initial_site] = False
        self.exc_index[0] = np.array([self.initial_site]) #Fill excited index
        
        #self.exc_dump = [self.initial_site] #Store sites excited at each timestep
        self.times = [0] #Store time site was excited
      
    
    @profile
    def run(self):
    #plots consecutive positions of leader for each wave
        
        self.initial_fire()
        self.time_list = [0]    #time given in wavefront units
        self.pos_list = [self.initial_site] #list of positions of leaders
        
        indices = np.arange(self.L)
        
        t=0 #initial real time
        count = 1
        gate1=False
        while count<self.T:
                
            prob_array = np.random.rand(self.L)<self.p
            exc_right = (self.exc_index[t%self.R]+1)%self.L #Sites to the right of previously excited
            exc_left = (self.exc_index[t%self.R]-1)%self.L #Sites to the right of previously excited
             
            try:
                a = np.where(exc_right == 0)[0][0]
                exc_right = np.delete(exc_right, a)
            except IndexError:
                pass
            try:
                b = np.where(exc_left == L-1)[0][0]
                exc_left = np.delete(exc_left, b)
            except IndexError:
                pass
                 
            self.exc_array *= False
            self.exc_array[exc_right] = True
            self.exc_array[exc_left] = True
            self.exc_array += prob_array #Add spontaneous excitations
            self.exc_array *= self.ref_array #Remove refractory cells
            exc_ind = indices[self.exc_array] #indices of the excited state
             
            self.ref_array[exc_ind] = 0 
            t += 1

            if t >= self.R:
                self.ref_array[self.exc_index[t % self.R]] = 1 #Cells which excited R steps ago enter resting state
            self.exc_index[t % self.R] = exc_ind #Replace excited cell index
             
            #self.exc_dump += exc_ind.tolist() #Store excited cells for plotting
            #self.times += [t] * len(exc_ind) #Store time cell was activated at
            
            #False if excited site list is empty, True otherwise
            exc_bool=any(self.exc_array)
             
            #only stores leader positions
            gate2=gate1*exc_bool
            if gate2 == True:
                if len(exc_ind)>1:
                    shift = [abs(number - self.pos_list[-1]) for number in exc_ind]
                    m, i = min((v,i) for i,v in enumerate(shift))
                    #n, j = min((v,i) for i,v in enumerate(shift))
                    #temp = [i, j]
                    #new_i=np.random.randint(len(temp))
                    exc_ind = exc_ind[i]
                self.pos_list.append(int(exc_ind))        
                gate1=False
                count += 1
            if exc_bool == False:
                gate1=True
        
        self.time_list = range(1, self.T+1)
        
# =============================================================================
#         plt.scatter(self.time_list, self.pos_list, s=0.8, color='k')
#         plt.xlabel('Time')
#         plt.ylabel('Leader')
# =============================================================================

        np.savetxt('2048_open.csv', [v for v in zip(self.time_list, self.pos_list)],fmt='%i', delimiter=',')

